package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"strings"
	"time"

	js "yourmodule/jsonstream"
)

// Record represents a data record.
type Record struct {
	ID    int     `json:"id"`
	Name  string  `json:"name"`
	Email string  `json:"email"`
	Score float64 `json:"score"`
}

func main() {
	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancel()

	// Example 1: Simple processing
	fmt.Println("=== シンプルな処理 ===")
	simpleExample(ctx)

	// Example 2: Chained transforms
	fmt.Println("\n=== チェーン変換 ===")
	chainedExample(ctx)

	// Example 3: File processing with stats
	fmt.Println("\n=== ファイル処理 ===")
	fileExample(ctx)
}

func simpleExample(ctx context.Context) {
	cfg := js.DefaultConfig()
	cfg.NumWorkers = 4

	// スコア正規化とフィルタリング
	transform := func(r Record) (*Record, error) {
		if r.Score <= 0 {
			return nil, nil // フィルタアウト
		}
		r.Score = r.Score / 100.0
		return &r, nil
	}

	processor := js.New(cfg, transform)

	// テストデータ
	data := strings.NewReader(`{"id":1,"name":"Alice","email":"alice@example.com","score":85}
{"id":2,"name":"Bob","email":"bob@example.com","score":0}
{"id":3,"name":"Carol","email":"carol@example.com","score":92}`)

	outputChan, errChan := processor.Process(ctx, data)

	// エラーを非同期で処理
	go js.DrainErrors(errChan, func(err error) {
		fmt.Fprintf(os.Stderr, "エラー: %v\n", err)
	})

	// 結果を収集
	for record := range outputChan {
		fmt.Printf("処理済み: %+v\n", record)
	}

	fmt.Println(processor.Stats())
}

func chainedExample(ctx context.Context) {
	// 複数の変換を組み合わせ
	transform := js.Chain(
		// バリデーション
		js.Validate(func(r Record) error {
			if r.Email == "" {
				return fmt.Errorf("email is required")
			}
			return nil
		}),
		// フィルタ
		js.Filter(func(r Record) bool {
			return r.Score > 0
		}),
		// 変換
		js.Map(func(r Record) Record {
			r.Score = r.Score / 100.0
			r.Name = strings.ToUpper(r.Name)
			return r
		}),
	)

	processor := js.New(js.DefaultConfig(), transform)

	data := strings.NewReader(`{"id":1,"name":"Alice","email":"alice@example.com","score":85}
{"id":2,"name":"Bob","email":"","score":70}
{"id":3,"name":"Carol","email":"carol@example.com","score":-5}`)

	outputChan, errChan := processor.Process(ctx, data)

	go js.DrainErrors(errChan, func(err error) {
		fmt.Fprintf(os.Stderr, "⚠ %v\n", err)
	})

	results, _ := js.Collect(ctx, outputChan)
	for _, r := range results {
		fmt.Printf("%+v\n", r)
	}
}

func fileExample(ctx context.Context) {
	cfg := js.DefaultConfig()
	cfg.NumWorkers = 8
	cfg.BufferSize = 2000

	transform := js.Map(func(r Record) Record {
		r.Score = r.Score / 100.0
		return r
	})

	processor := js.New(cfg, transform)

	start := time.Now()
	outputChan, errChan, err := processor.ProcessFile(ctx, "large_data.json")
	if err != nil {
		fmt.Printf("ファイルオープン失敗: %v\n", err)
		return
	}

	// エラー収集
	var errCount int
	go func() {
		errCount = js.DrainErrors(errChan, nil)
	}()

	// 結果処理
	count := 0
	for range outputChan {
		count++
		if count%10000 == 0 {
			fmt.Printf("進捗: %d 件処理済み\n", count)
		}
	}

	stats := processor.Stats()
	stats.Duration = time.Since(start)
	fmt.Println(stats)
}
